{
  "rules": [
    {
      "type": "prd",
      "content": "# 가상계좌 결제 자동화 테스트 플랫폼 PRD\n\n## 1. 개요\nPython + Playwright 기반의 모바일 브라우저 E2E 자동화 테스트 스크립트/툴을 제공하여, 스타트업·소규모 개발팀이 ‘가상계좌’ 결제 성공 흐름을 클릭 한 번으로 검증할 수 있게 한다.\n\n## 2. 목표\n1. 수동 테스트에 소모되는 시간을 80% 이상 절감한다.\n2. 고객사 데모 전에 QA 엔지니어가 5분 이내에 결제 성공 여부를 확인할 수 있도록 한다.\n3. 스크립트 구조를 모듈화해 다른 결제 수단 추가 시 코드 변경을 30% 미만으로 유지한다.\n\n## 3. 주요 사용자\n- QA 엔지니어 / 테스트 자동화 담당자 (소규모 개발팀 1‒5명)\n\n## 4. 핵심 사용 시나리오\n데모 전 QA 엔지니어가 터미널 또는 GUI 런처에서 ‘Run Test’ 버튼을 눌러 전체 결제 성공 흐름을 자동 실행하고 리포트를 받아본다.\n\n## 5. Pain Point & Value Proposition\n| Pain Point | Value Proposition |\n|-------------|------------------|\n| 수동 테스트로 시간·인력 소모 | 클릭 한 번으로 전체 흐름 자동 검증 |\n| 모바일 브라우저 재현 어려움 | Playwright 모바일 에뮬레이션으로 신뢰성 확보 |\n| 시나리오 확장 시 반복 작업 | 파라미터화된 모듈 구조로 재사용성 보장 |\n\n## 6. 기능 범위\n### 6.1 필수 기능 (MVP)\n1. 모바일 브라우저 기반 ‘가상계좌’ 결제 성공 시나리오 자동 실행\n2. 테스트 결과 HTML & 콘솔 리포트 생성\n3. Android / iOS 에뮬레이터 프로필 지원\n4. 다른 결제 수단 시나리오를 위한 모듈·파라미터 구조\n5. 실패 단계 자동 스크린샷 & 로그 수집\n\n### 6.2 부가기능 (Nice-to-Have)\n1. 테스트 데이터 파라미터화 다중 실행\n2. Slack / Email 알림 전송\n3. 클라우드 디바이스 팜 연동 옵션 (BrowserStack 등)\n\n## 7. 제외 범위 (Out of Scope)\n- CI 파이프라인 자동 연결 기능 (추후 버전)\n- 대시보드 누적 통계 관리\n\n## 8. 기술 스택\n- 언어: Python 3.x\n- 테스트 프레임워크: Playwright Python\n- 리포팅: Playwright HTML Reporter + Rich 콘솔 출력\n- 실행 환경: 로컬/CI 어디서나 Docker 컨테이너로 구동 가능\n\n## 9. 개발 전략\n- MVP → Incremental 개선\n- 2주 스프린트 단위 애자일 적용(소규모 팀)\n\n## 10. 성공 지표 (KPIs)\n1. 평균 테스트 실행 시간 < 3분\n2. 도입 후 1개월 내 수동 테스트 시간 80% 감소\n3. 다른 결제 수단 추가 시 평균 개발 시간 < 0.5일\n\n## 11. 일정(High-Level)\n| 주차 | 목표 |\n|----|-------|\n| 1주 | 요구사항 확정 & 프로젝트 세팅 |\n| 2‒3주 | 가상계좌 시나리오 스크립트 개발 & 리포트 |\n| 4주 | 실패 캡처, 파라미터화, 기본 알림 기능 |\n| 5주 | 내부 베타 & 피드백 반영 |\n\n## 12. 리스크 & 대응책\n1. 실제 결제 페이지 변경 → CSS selector 변화 감지 유틸리티 도입\n2. 모바일 UA 차이 → 주요 기기 프로필 사전 테스트\n\n## 13. 가정\n- 결제 테스트 링크는 지속적으로 접근 가능\n- 팀원은 Python 기본 지식 보유\n\n## 14. 승인\nProduct Owner: ____    Date: ____",
      "writedAt": "2025-09-01T00:16:12.073Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: Python과 Playwright를 사용하여 가상계좌 결제 성공 흐름을 자동화하는 E2E 테스트 플랫폼을 구축합니다. Docker 컨테이너를 통해 로컬 및 CI 환경에서 일관된 실행 환경을 제공하며, 모듈화된 스크립트 구조를 통해 다른 결제 수단에 대한 확장성을 확보합니다.\n- **Core Technology Stack**: Python, Playwright, Docker\n- **Key Technical Objectives**:\n    - 평균 테스트 실행 시간 3분 이내\n    - 다른 결제 수단 추가 시 평균 개발 시간 0.5일 이내\n    - 수동 테스트 시간 80% 감소\n- **Critical Technical Assumptions**:\n    - 결제 테스트 링크는 지속적으로 접근 가능\n    - 팀원은 Python 기본 지식 보유\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Language          | Python 3.x                  | 높은 생산성, 풍부한 라이브러리 지원, 테스트 자동화에 적합 |\n| Testing Framework | Playwright                  | 크로스 브라우저 E2E 테스트, 모바일 에뮬레이션, 자동 대기 기능 제공 |\n| Reporting         | Playwright HTML Reporter + Rich | 테스트 결과 시각화, 디버깅 용이성, 콘솔 요약 정보 제공 |\n| Containerization  | Docker                      | 일관된 실행 환경 제공, 배포 용이성, 환경 격리 |\n| Configuration     | YAML                        | 사람이 읽기 쉬운 설정 파일 형식, 데이터 관리 용이 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Test Runner**:\n    - 테스트 시나리오 실행을 담당합니다.\n    - Sub-building blocks:\n        - Command-line interface (CLI)\n        - Configuration Loader\n        - Test Orchestrator\n- **Playwright Automation**:\n    - Playwright를 사용하여 브라우저 자동화를 수행합니다.\n    - Sub-building blocks:\n        - Browser Context Manager\n        - Page Interaction Handler\n        - Screenshot & Log Capture\n- **Reporting Module**:\n    - 테스트 결과를 HTML 리포트 및 콘솔에 출력합니다.\n    - Sub-building blocks:\n        - HTML Report Generator\n        - Console Output Formatter\n- **Notification Service (Optional)**:\n    - 테스트 결과를 Slack 또는 Email로 알립니다 (부가 기능).\n    - Sub-building blocks:\n        - Slack API Integration\n        - Email Sender\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Test Runner] --> B[Playwright Automation]\n    B --> C[Reporting Module]\n    A --> D[Configuration Loader]\n    C --> E[Notification Service (Optional)]\n    D --> F[YAML Configuration]\n```\n\n- **Test Runner**: 사용자가 테스트 실행 명령을 내리면, Test Runner가 Configuration Loader를 통해 설정을 로드하고, Playwright Automation을 호출하여 테스트를 실행합니다.\n- **Playwright Automation**: Playwright Automation은 Configuration Loader에서 로드된 설정을 바탕으로 브라우저를 제어하고, 테스트 시나리오를 수행합니다.\n- **Reporting Module**: 테스트 실행 결과는 Reporting Module을 통해 HTML 리포트 및 콘솔에 출력됩니다.\n- **Notification Service (Optional)**: 테스트 결과에 따라 Notification Service를 통해 Slack 또는 Email로 알림을 전송합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 결제 흐름, 리포팅, 설정 관리 등 도메인별로 코드를 분리합니다.\n- **Layer-Based Architecture**: 테스트 시나리오, 브라우저 제어, 리포트 생성 등 레이어별로 코드를 분리합니다.\n- **Feature-Based Modules**: 가상계좌, 카드 결제 등 결제 수단별로 모듈을 구성합니다.\n- **Shared Components**: 공통 유틸리티 함수, 설정 파일 등을 공유 모듈에 저장합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── config.yaml                 # Configuration file (휴대폰번호, 은행코드 등)\n├── run_test.py                 # Main script to run tests\n├── Dockerfile                  # Docker configuration\n├── tests/                      # Test scenarios\n│   ├── __init__.py\n│   ├── vbank_success.py      # 가상계좌 결제 성공 시나리오\n│   ├── card_success.py       # 카드 결제 성공 시나리오 (부가 기능)\n│   └── ...\n├── pages/                      # Page object model\n│   ├── __init__.py\n│   ├── payment_page.py         # 결제 페이지 관련 로직\n│   ├── ...\n├── utils/                      # Utility functions\n│   ├── __init__.py\n│   ├── config_loader.py        # 설정 파일 로더\n│   ├── ...\n├── reports/                    # Test reports and screenshots\n│   ├── ...\n├── requirements.txt            # Python dependencies\n└── README.md\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Playwright는 브라우저와 통신하여 페이지를 제어하고, API 요청을 보냅니다.\n- **Database Interaction**: 데이터베이스는 사용하지 않습니다. 설정 파일(`config.yaml`)에서 테스트 데이터를 읽어옵니다.\n- **External Service Integration**: Slack API 또는 Email 서버를 통해 알림을 전송합니다 (부가 기능).\n- **Data Synchronization**: 데이터 동기화는 필요하지 않습니다.\n\n## 4. Performance & Optimization Strategy\n- **병렬 테스트 실행**: Playwright의 기능을 활용하여 여러 테스트를 병렬로 실행하여 전체 테스트 시간을 단축합니다.\n- **브라우저 컨텍스트 재사용**: 각 테스트 시나리오마다 새로운 브라우저 컨텍스트를 생성하는 대신, 기존 컨텍스트를 재사용하여 브라우저 초기화 시간을 줄입니다.\n- **코드 최적화**: 불필요한 코드 실행을 줄이고, 효율적인 알고리즘을 사용하여 코드 실행 속도를 향상시킵니다.\n- **이미지 최적화**: 실패 시 스크린샷을 캡처할 때, 이미지 품질을 조정하여 저장 공간을 절약하고 전송 시간을 줄입니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Python, Playwright, Docker 환경 설정 및 기본 프로젝트 구조 구축\n- **Essential Features**:\n    - 모바일 브라우저 기반 ‘가상계좌’ 결제 성공 시나리오 자동 실행\n    - 테스트 결과 HTML & 콘솔 리포트 생성\n    - Android / iOS 에뮬레이터 프로필 지원\n    - 다른 결제 수단 시나리오를 위한 모듈·파라미터 구조\n    - 실패 단계 자동 스크린샷 & 로그 수집\n- **Basic Security**: 설정 파일 암호화 (필요 시)\n- **Development Setup**: 개발 환경 설정 및 CI/CD 기본 설정 (필수적인 경우)\n- **Timeline**: 2-3주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**:\n    - 테스트 데이터 파라미터화 다중 실행\n    - Slack / Email 알림 전송\n    - 클라우드 디바이스 팜 연동 옵션 (BrowserStack 등)\n- **Performance Optimization**: 테스트 실행 시간 단축 및 리소스 사용량 최적화\n- **Enhanced Security**: 보안 취약점 점검 및 보완\n- **Monitoring Implementation**: 테스트 실행 결과 모니터링 시스템 구축 (필수적인 경우)\n- **Timeline**: 2-3주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**:\n    - Playwright 업데이트로 인한 API 변경 가능성\n    - 모바일 브라우저 에뮬레이션의 부정확성\n- **Performance Risks**:\n    - 테스트 실행 시간 증가\n    - 리소스 부족\n- **Security Risks**:\n    - 설정 파일에 저장된 민감 정보 노출 가능성\n- **Integration Risks**:\n    - Slack API 또는 Email 서버와의 연동 실패 가능성\n- **Mitigation Strategies**:\n    - Playwright 업데이트 시 변경 사항을 신속하게 반영\n    - 실제 기기 테스트 병행\n    - 병렬 테스트 실행 및 코드 최적화\n    - 설정 파일 암호화 및 접근 권한 관리\n    - Slack API 또는 Email 서버 연동 테스트 수행\n\n### Project Delivery Risks\n- **Timeline Risks**:\n    - 개발 지연\n    - 예상치 못한 기술적 문제 발생\n- **Resource Risks**:\n    - 개발 인력 부족\n    - 기술 전문가 부족\n- **Quality Risks**:\n    - 코드 품질 저하\n    - 테스트 커버리지 부족\n- **Deployment Risks**:\n    - 배포 환경 문제\n    - 설정 오류\n- **Contingency Plans**:\n    - 개발 일정 조정\n    - 추가 인력 투입\n    - 코드 리뷰 및 충분한 테스트 수행\n    - 배포 전 충분한 테스트 및 백업 전략 수립\n",
      "writedAt": "2025-09-01T00:16:12.073Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline: Virtual Account Payment Automation Testing Platform\n\n## 1. Project Overview\n\nThis project involves creating an automated E2E testing platform using Python and Playwright to verify virtual account payment success flows. The platform will be Dockerized for consistent execution across local and CI environments.  The core deliverable is a reliable, automated test suite that reduces manual testing effort and ensures payment functionality.\n\nKey architectural decisions:\n\n*   **Python & Playwright**: For test automation and browser interaction.\n*   **Docker**: For consistent environment and deployment.\n*   **Modular Design**: To support adding new payment methods easily.\n\n## 2. Core Principles\n\n*   **Readability**: Code should be easily understood by any team member.\n*   **Maintainability**: Code should be easy to modify and extend.\n*   **Testability**: Code should be designed to be easily tested.\n*   **Reusability**: Components should be designed for reuse across different test scenarios.\n*   **Efficiency**: Tests should execute quickly and efficiently.\n\n## 3. Language-Specific Guidelines\n\n### Python\n\n#### File Organization and Directory Structure\n\n*   Follow the project structure as defined in the TRD.\n*   Group related classes and functions into modules.\n*   Use meaningful file and directory names.\n\n#### Import/Dependency Management\n\n*   Use `requirements.txt` to manage dependencies.  Always update this file when adding or removing dependencies.\n*   Use absolute imports for internal modules (e.g., `from utils.config_loader import load_config`).\n*   Use relative imports within the same package (e.g., `from . import payment_page` inside `pages` directory).\n*   Sort imports alphabetically within each group (standard library, third-party, local).\n*   Avoid wildcard imports (`from module import *`).\n\n#### Error Handling Patterns\n\n*   Use `try...except` blocks to handle expected exceptions.\n*   Log exceptions with sufficient context using the `logging` module.\n*   Reraise exceptions only when necessary, preserving the original traceback.\n*   Avoid bare `except:` clauses; always catch specific exception types.\n*   Implement retry mechanisms for transient errors (e.g., network issues).\n\n```python\n# MUST: Proper error handling with logging\nimport logging\n\ntry:\n    result = perform_network_operation()\nexcept NetworkError as e:\n    logging.error(f\"Network operation failed: {e}\")\n    # Implement retry logic here if appropriate\n    raise  # Reraise if the error cannot be handled\n```\n\n### Playwright\n\n#### Page Object Model\n\n*   Implement the Page Object Model (POM) for interacting with web pages.\n*   Each page object should encapsulate the locators and actions for a specific page or component.\n*   Page objects should expose methods that represent user actions on the page.\n\n#### Locators\n\n*   Use meaningful and resilient locators (e.g., `data-testid` attributes) instead of fragile CSS selectors.\n*   Avoid using XPath locators unless absolutely necessary.\n*   Group locators within the page object class.\n*   Use parameterized locators when appropriate.\n\n#### Asynchronous Operations\n\n*   Always use `await` when calling Playwright asynchronous methods.\n*   Handle potential timeouts gracefully.\n\n#### Assertions\n\n*   Use Playwright's built-in assertions or `pytest` assertions for validating test results.\n*   Provide clear and informative error messages for failed assertions.\n\n```python\n# MUST: Using await with Playwright methods\nasync def click_button(self, page, locator):\n    await page.locator(locator).click() # Using await\n\n# MUST: Proper assertion with informative message\nfrom playwright.sync_api import expect\n\nasync def check_element_text(page, locator, expected_text):\n    element = page.locator(locator)\n    expect(element).to_have_text(expected_text, timeout=5000)\n```\n\n### Docker\n\n*   Use a `.dockerignore` file to exclude unnecessary files from the Docker image.\n*   Use multi-stage builds to minimize the image size.\n*   Specify a non-root user for running the application inside the container.\n*   Use environment variables for configuring the application.\n\n### YAML\n\n*   Use YAML for configuration files.\n*   Keep configuration files simple and well-structured.\n*   Use comments to explain the purpose of each configuration option.\n*   Validate configuration data when loading it.\n\n## 4. Code Style Rules\n\n#### MUST Follow:\n\n*   **PEP 8 Compliance**: Adhere to PEP 8 style guidelines for Python code.\n    *   Rationale: Ensures consistent code formatting and readability.\n*   **Docstrings**: Write docstrings for all modules, classes, methods, and functions.\n    *   Rationale: Provides documentation within the code itself, improving understanding and maintainability.\n*   **Meaningful Names**: Use descriptive and meaningful names for variables, functions, and classes.\n    *   Rationale: Makes the code self-documenting and easier to understand.\n*   **Type Hints**: Use type hints to improve code readability and help catch type errors.\n    *   Rationale: Improves code clarity and enables static analysis tools to detect type-related issues.\n*   **Logging**: Use the `logging` module for logging events, errors, and debugging information.\n    *   Rationale: Provides a structured way to record application behavior, aiding in debugging and monitoring.\n*   **Keep functions short**: Functions should ideally be less than 50 lines of code.\n    *   Rationale: Easier to read, understand, and test.  Promotes code reuse.\n*   **Single Responsibility Principle (SRP)**: Each module, class, or function should have only one reason to change.\n    *   Rationale: Increases modularity, testability, and maintainability.\n\n```python\n# MUST: Example of a well-documented function with type hints\ndef calculate_discount(price: float, discount_percentage: float) -> float:\n    \"\"\"\n    Calculates the discounted price.\n\n    Args:\n        price: The original price.\n        discount_percentage: The discount percentage (e.g., 10 for 10%).\n\n    Returns:\n        The discounted price.\n    \"\"\"\n    discount_amount = price * (discount_percentage / 100)\n    return price - discount_amount\n```\n\n#### MUST NOT Do:\n\n*   **Code Duplication**: Avoid duplicating code.  Extract common logic into reusable functions or classes.\n    *   Rationale: Reduces maintenance effort and the risk of introducing bugs in multiple places.\n*   **Hardcoded Values**: Avoid hardcoding values directly in the code.  Use configuration files or environment variables instead.\n    *   Rationale: Makes the application more configurable and easier to deploy in different environments.\n*   **Ignoring Exceptions**: Never ignore exceptions without handling them.  At least log the exception.\n    *   Rationale: Prevents unexpected behavior and makes it easier to diagnose problems.\n*   **Complex Conditional Statements**: Avoid overly complex conditional statements.  Simplify them using helper functions or design patterns.\n    *   Rationale: Improves code readability and maintainability.\n*   **Over-commenting**: Avoid writing obvious comments. Focus on explaining complex logic or design decisions.\n    *   Rationale: Reduces clutter and keeps the code focused on what it does.\n*   **Committing Secrets**: Do not commit sensitive information (e.g., API keys, passwords) to the repository. Use environment variables or secret management tools.\n    *   Rationale: Protects sensitive data from unauthorized access.\n*   **Global mutable state**: Avoid using global variables that can be modified from anywhere in the code.\n    *   Rationale: Makes code harder to reason about and can lead to unexpected side effects.\n\n```python\n# MUST NOT: Hardcoding values\ndef process_payment(amount):\n    # BAD: Hardcoded tax rate\n    tax = amount * 0.05\n    # ...\n\n# GOOD: Using a configuration value\nimport configparser\nconfig = configparser.ConfigParser()\nconfig.read('config.ini')\n\ndef process_payment(amount):\n    tax_rate = float(config['TAX']['rate'])\n    tax = amount * tax_rate\n    # ...\n```\n\n## 5. Architecture Patterns\n\n*   **Component/module structure guidelines**:\n    *   Follow the domain-driven organization strategy outlined in the TRD.\n    *   Each module should correspond to a specific domain or feature.\n    *   Modules should have clear interfaces and well-defined responsibilities.\n*   **Data flow patterns**:\n    *   Data should flow in a unidirectional manner.\n    *   Avoid circular dependencies between modules.\n    *   Use data transfer objects (DTOs) to pass data between layers.\n*   **State management conventions**:\n    *   Since the application is primarily a test automation tool, complex state management is not required.\n    *   Use local variables within functions or classes to manage state.\n    *   Avoid using global state variables.\n*   **API design standards**:\n    *   Define clear and consistent interfaces for modules and classes.\n    *   Use descriptive method names.\n    *   Use type hints to specify the expected data types for input parameters and return values.\n\n```python\n# MUST: Example of a Page Object Model (POM) class\nclass PaymentPage:\n    def __init__(self, page):\n        self.page = page\n        self.account_number_field = \"input#account_number\"\n        self.submit_button = \"button#submit_payment\"\n\n    async def enter_account_number(self, account_number):\n        await self.page.locator(self.account_number_field).fill(account_number)\n\n    async def submit_payment(self):\n        await self.page.locator(self.submit_button).click()\n\n    async def get_confirmation_message(self):\n        return await self.page.locator(\"div#confirmation_message\").inner_text()\n```\n\n```python\n# MUST NOT: Example of an anti-pattern (tight coupling)\n# Avoid tight coupling between modules.\n\n# BAD: Directly accessing internal variables of another module\n# module_a.py\nclass ModuleA:\n    def __init__(self):\n        self._internal_data = \"Sensitive Data\"  # Private variable\n\n# module_b.py\nfrom module_a import ModuleA\n\nmodule_a = ModuleA()\nprint(module_a._internal_data)  # Directly accessing private variable (BAD)\n\n# GOOD: Using a proper interface\n# module_a.py\nclass ModuleA:\n    def __init__(self):\n        self._internal_data = \"Sensitive Data\"\n\n    def get_data(self):  # Public method to access data\n        return self._internal_data\n\n# module_b.py\nfrom module_a import ModuleA\n\nmodule_a = ModuleA()\nprint(module_a.get_data())  # Accessing data through the public interface (GOOD)\n```\n",
      "writedAt": "2025-09-01T00:16:12.073Z"
    }
  ]
}